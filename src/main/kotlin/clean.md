1. Моделирование данных (Data Classes)
   Вместо того чтобы работать с сырыми данными (списком строк p и флагами), мы создали структуру:

Item: хранит имя и цену. Теперь код «знает», что телефон стоит 500.0, а не ищет это значение через if-else.

Order: объединяет товары и параметры доставки. Это делает сигнатуру метода processOrder чистой — мы передаем один объект вместо набора разрозненных переменных.

2. Инкапсуляция констант
   В «грязном» коде числа 1000, 0.1 и 50 были «магическими» — их смысл не был очевиден.

Константы вынесены их в companion object. Это аналоги static final в Java. Теперь, если стоимость доставки изменится, её нужно будет поправить только в одном месте.

3. Идиоматичная обработка коллекций
   Вместо ручного цикла for и переменной-аккумулятора var t:

Функция sumOf — это стандартная функция Kotlin. Она делает код декларативным: мы говорим «просуммируй цены», а не объясняем компьютеру, как именно перебирать индексы.

4. Декомпозиция (Single Responsibility)
   Метод process в грязном коде делал три вещи: считал деньги, выводил текст и «сохранял» данные. В чистом коде я разделил это на 3 приватных метода:

calculateFinalPrice: только математика (скидки и доставка).

printSummary: только отображение.

saveToDatabase: только имитация работы с БД.

Это упрощает тестирование: теперь вы можете протестировать расчет цены отдельно от вывода текста на экран.

5. Читаемость (Self-Documenting Code)
   Сравните:

Было: t = t - (t * 0.1) (Что такое 0.1? Почему мы это вычитаем?)

Стало: total -= total * DISCOUNT_RATE (Сразу понятно: мы применяем ставку скидки).